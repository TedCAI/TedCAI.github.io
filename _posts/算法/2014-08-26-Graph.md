---
layout: post
title: 图(graph)
category: 算法
description: 图
tags: ["C++","算法","数据结构"]
---

这篇文章记录了我学习图找到的一些有用的资料以及edX上Data Structures and Algorithms第五周的笔记.

### 图(graph)的概念
1. G = (V;E)   vertex;edge
2. 邻接关系: adjacency - 顶点与顶点的关系
3. 关联关系: incidence(入射的) - 顶点与相关的某条边的关系
4. 暂时忽略自环的边

5. 无向边(undirected edge): 邻接顶点的次序无所谓
6. 无向图(undigraph):所有边均无方向的图
7. 有向边(directed edge):u和v分别称作尾(tail),头(head)
8. 有向图(digraph):所有边均为有向边
9. 混合图(mixed graph)
10. 关注有向图: 有向图可以表示并且实现无向图以及混合图

11. 路径(path): path(non-simple path),simple path(不含重复节点的路径)
12. 环路(cycle): 起点终点重合; 也有简单/不简单之分, 区别为是否包含重复节点
13. 有向无环图(DAG,directed acyclic graph)
14. Eulerian tour: 经过*所有边*恰好一次的环路
15. Hamiltonian tour: 经过所有顶点恰好一次的环路

### 图(graph)的代码实现
1.接口

```
/*Graph template*/
template <typename Tv,typename Te> class Graph{
  private:
	void reset(){  //所有顶点,边的辅助信息复位
		for(int i=0;i<n;i++){	//顶点
			status(i)  = UNDISCOVERED;
			dTime(i)   = fTime(i) = -1;
			parent(i)  = -1;
			priority(i)= INT_MAX;
			
			for(int j=0;j<n;j++)
				if(exists(i,j)) status(i,j) = UNDETERMINED;
		}
	}
	
  public:	/*...顶点操作,边操作,图算法*/
}//Graph
```

2.邻接矩阵(Adjacency matrix)+关联矩阵(Incidence matrix)
(1)邻接矩阵(Adjacency matrix):描述顶点之间相互邻接关系的一种形式
(2)有n个顶点,矩阵是n*n大小的
(3)M(i,j)表示顶点i与顶点j之间是否存在一条边(是否关联),是取1,否取0

(4)无向图
-邻接矩阵对称:M(i,j)=M(j,i)
-对角线元素:自环

(5)无权(non-weighted)图:(binary)bit矩阵
(6)有权(weighted)	 图:  float/int矩阵

3.关联矩阵(Incidence matrix)
(1)n个节点,e条边
(2)矩阵:n行e列,n*e
(3)M(i,j)表示i节点e边是否存在关联关系
(4)存在关系记为1,不存在记为0
(5)任何一列,恰好只有两个单元的数值为1,其余为0 (意义:一条边连接两个点)

4.顶点(vertex)和边(edge)

```
/*Vertex*/

typedef enum {UNDISCOVERED,DISCOVERED,VISITED} VStatus;
template <typename Tv> struct Vertex{	//顶点对象
	Tv data;					//数据
	int inDegree,outDegree;		//出入度数(和其他顶点相关联)
	VStatus status;				//(如上三种)状态
	int dTime,fTime;			//时间标签
	int parent;					//在遍历树中的父节点
	int priority;				//在遍历树中的优先级(最短通路,极短跨边等)
	
	Vertex(	Tv const & d ):		//构造新顶点
	data(d),inDegree(0),outDegree(0),status(UNDISCOVERED),//初始状态
	dTime(-1),fTime(-1),			 parent(-1);
	priority(INT_MAX){}
};
```

```
/*Edge*/

typedef enum {UNDETERMINED,TREE,CROSS,FORWARD,BACKWARD} EStatus;
template <typename Te> struct Edge{	//边对象
	Te      data;	//数据
	int     weight;	//权重
	EStatus status;	//类型
	Edge( Te const & d, int w):		//构造新边
		data(d),weight(w),status(UNDETERMINED){}
}
```

5.邻接矩阵(Adjacency matrix)
(1)基于邻接矩阵,实现图结构的一种可行方式

```
/*GraphMatrix*/

template <typename Tv,typename Te> 
class GraphMatrix: public Graph<Tv,Te>{
  private:
    Vector< Vertex<Tv> > V;				//顶点集
	Vector< Vector< Edge<Te>* > > E; 	//边集

  public:
    /*操作接口:顶点相关，边相关...*/
	GraphMatrix(){ n=e=0; }	//构造
	~GraphMatrix(){			//析构
		for (int j=0;j<n;j++)
		for (int k=0;k<n;k++)
			delete E[j][k];	//清除所有动态申请的边记录
	}
}
```

6.顶点操作
(1)基本操作

```
/*顶点基本操作*/

Tv &  vertex(int i) { return V[i].data; }			//数据
int inDegree(int i) { return V[i].inDegree; }		//入度(和其他顶点相关联)
int outDegree(int i){ return V[i].outDegree; }		//出度

Vstatus & status(int i){ return V[i].status; }		//状态

int &  dTime(int i){ return V[i].dTime; }			//时间标签dTime
int &  fTime(int i){ return V[i].fTime; }			//时间标签fTime
int & parent(int i){ return V[i].parent; }			//在遍历树中的父亲
int & priority(int i){ return V[i].priority; }		//优先级数
```

(2)对于任意顶点i,如何 *枚举* 其所有的邻接顶点neighbor?

```
int nextNbr(int i,int j){	//对于顶点i,若已枚举至邻居j,则转向下一邻居
	while( (-1<j) && !exists(i,--j) );  //逆向顺序查找,O(n)
	return j;
}//改用邻接表可提高至O(1+outDegree(i))
```

```
/*确定第一个有效邻居*/

int firstNbr(int i){
	return nextNbr(i,n);
}//首个邻居
```

7.边操作
(1)

```
/*判断边是否存在*/
bool exists(int i,int j){	//判断边(i,j)是否存在
	return (0<=i) && (i<n) && (0<=j) && (j<n)
		   && E[i][j]!=NULL;	//短路求值
}

/*以下假定exists(i,j)...*/
Te & edge(int i,int j){			//边(i,j)的数据
	return E[i][j]->data;
}

Estatus & status(int i,int j){	//边的状态
	return E[i][j]->status;
}

int & weight(int i,int j){		//权重
	return E[i][j]->weight;
}
```

(2)边插入

```
void insert(Te const & edge,int w,int i,int j){//插入(i,j,w)
	if(exists(i,j)) return; 		//忽略已有的边
	E[i][j] = new Edge<Te>(edge,w);	//创建新边
	e++;				//更新边计数
	V[i].outDegree++; 	//更新关联顶点i的*出度*
	V[j].inDegree++;	//更新关联顶点j的*入度*
}
```

### 一些资料
1.大话数据结构-图
http://www.cnblogs.com/w-wanglei/p/figure.

2.http://blog.chinaunix.net/uid-21813514-id-3866951.html

3.enum枚举(讲解的很好)
http://hi.baidu.com/yuleishou/item/caacae872190031ec216272f