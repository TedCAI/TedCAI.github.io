---
layout: post
title: 向量(vector)
category: 算法
description: vector
tags: ["C++","算法","数据结构"]
---

这篇文章记录了我学习列表找到的一些有用的资料以及edX上Data Structures and Algorithms第二周的笔记.

### 接口与实现
1.ADT/implementation
2.Abstract Data Type vs Data Structure
(1)ADT 		 = 数据模型 + 定义在该模型上额度一组操作
			   (抽象定义,外部逻辑特性,不考虑复杂度,不涉及数据储存方式)
(2)数据结构  = 基于某种特定语言,实现ADT的一整套算法
			   (具体实现,完整算法,考虑复杂度,考虑数据储存机制)
			   
3.从数组到向量
(1)Array的每一个元素都可直接访问
(2)A[i]=A+i*s (s为单个元素占用的空间量)
(3)故称作线性数组(linear array)

4.向量是数组的抽象与泛化,由一组元素按现行次序封装而成
(1)各元素与[0,n)内的秩(rank)一一对应  (call-by-rank)
(2)元素的类型不限于基本类型

5.ADT操作实例
(1)disordered():输出逆序对(inversion)的个数
(2)search():返回不超过输入元素(parameter)的最大的那个元素的最后的rank
(3)uniqufy():删除有序的向量重复的元素

6.Vector 模板类

```
/*Vector*/

typedef int Rank;			//秩
#define DEFAULT_CAPACITY 3	//默认初始向量(实际应用中可设置为更大,大概32?)

template<typename T> 
class Vector{
  private:
	Rank _size;			//规模
	int  _capacity;		//容量
	T *  _elem;			//数据区
  
  protected:
  /*...内部函数*/
  
  public:
  /*构造函数*/
  /*析构函数*/
  /*只读接口*/
  /*可写接口*/
  /*遍历接口*/
}

//构造函数
Vector<T>::Vector(int c = DEFAULT_CAPACITY){			//默认构造函数
	_elem = new T[_capacity = c];//首地址交给_elem
	_size = 0;
}

Vector::Vector(T const * A,Rank lo,Rank hi){			//数组区间复制
	copyFrom(A,lo,hi);
}			

Vector<T>::Vector(Vector<T> const & V,Rank lo,Rank hi)	//向量区间复制
{
	copyFrom(V._elem,lo,hi);
}

Vector<T>::Vector(Vector<T> const & V){					//向量整体复制
	copyFrom(V._elem)
}

Vector<T>::~Vector(){									//析构
	delete [] _elem;
}
```

//*关键:copyFrom
template<typename T>
void Vector<T>::copyFrom(T* const A,Rank lo,Rank hi){
	_elem = new T[_capacity = 2*(hi-lo)];	//2倍空间, 
											//可以hi-lo是因为[lo,hi)是[闭,开)空间
	_size = 0;								//规模清0
	while(lo < hi){							//A[lo,hi) traverse
		_elem[_size++] = A[lo++];			//复制至_elem[0,hi-lo)
	}
}

### 可扩充向量
1.目前静态空间管理,容量_capacity固定,有缺陷
(1)上溢(overflow): _elem[]空间不够,尽管系统仍有足够空间
(2)下溢(underflow):_elem[]元素很少,装填因子(load factor) lambda = _size/_capacity << 50%
*一般应用环境难以准确预测空间的需求量

2.动态空间管理
(1)在即将发生overflow时,适当地扩大内部数组的容量

```
/*扩容算法*/
template <typename T>
void Vector<T>::expand(){			//向量空间不足时扩容
	if(_size < _capacity) return;
	
	_capacity = max(_capacity,DEFAULT_CAPACITY); //不低于最小容量
	T * oldElem = _elem;
	_elem = new T[_capacity <<= 1];				 //左移,容量加倍, 应该写成_capacity<<1吧?
	
	for(int i=0;i<_size;i++){
		_elem[i] = oldElem[i];					 //T为基本类型,或已重载'='
	}
	delete [] oldElem;							 //释放原空间
}

//优势:封装性
//扩容之后数据区物理地址有所改变,却不会出现野指针
//一般数组动态重新分配地址后,原先指向它内部某些元素的一些指针可能无效,
//虽然它指向一个地址,但其中并没有存放我们所需要的数值
//e.g. *(array +3)指向第三个元素,重新分配后失效,
//	   *(vector+3)依然能指向第三个元素,都是用_elem统一指示
```

(2)一个关注点

```
//是否可以将向量扩容代码中的：
for (int i = 0; i < _size; i++) _elem[i] = oldElem[i];
//替代为：
memcpy(_elem, oldElem, _size * sizeof(T));

/*答案*/
//当T为非基本类型且有对应的复制构造函数以执行深复制时，前一段代码会调用复制构造函数而后一段只能进行浅复制。
```

3.递增式扩容